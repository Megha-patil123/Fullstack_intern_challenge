Project Structure
I will provide the code organized into the following file structure. You'll need to create these directories and files on your machine.

Backend (NestJS)

/fullstack-rating-app
  /backend
    /src
      /auth
      /stores
      /users
      /ratings
      /database
      app.module.ts
      main.ts
    .env.example
    package.json
    tsconfig.json

Frontend (ReactJs)

/fullstack-rating-app
  /frontend
    /src
      /components
      /pages
      /services
      App.css
      App.js
      index.css
      index.js
    .env.local.example
    package.json
Backend (NestJS) Code
First, initialize your NestJS project.

Bash

npx @nestjs/cli new backend
Then, install the necessary dependencies for the backend.

Bash

cd backend
npm install @nestjs/typeorm typeorm pg @nestjs/passport passport passport-local @nestjs/jwt @nestjs/bcrypt bcryptjs class-validator class-transformer
1. Environment Variables (.env.example)
Create a .env.example file in the backend directory.

DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USERNAME=your_username
DATABASE_PASSWORD=your_password
DATABASE_NAME=ratings_db
JWT_SECRET=your_secret_key
PORT=3000
Remember to create a .env file with your actual values.

2. Database Configuration & Schema
This is the core of the data model. We'll use TypeORM entities to define our database schema.

src/database/database.config.ts

TypeScript

import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import * as dotenv from 'dotenv';
dotenv.config();

export const databaseConfig: TypeOrmModuleOptions = {
  type: 'postgres',
  host: process.env.DATABASE_HOST || 'localhost',
  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
  username: process.env.DATABASE_USERNAME,
  password: process.env.DATABASE_PASSWORD,
  database: process.env.DATABASE_NAME,
  entities: [__dirname + '/../**/*.entity{.ts,.js}'],
  synchronize: true, // Not for production, use migrations instead
};
src/users/user.entity.ts

TypeScript

import { Entity, PrimaryGeneratedColumn, Column, OneToMany, Index } from 'typeorm';
import { Rating } from '../ratings/rating.entity';
import * as bcrypt from 'bcryptjs';

export enum UserRole {
  ADMIN = 'admin',
  NORMAL = 'normal',
  STORE_OWNER = 'store_owner',
}

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 60 })
  @Index()
  name: string;

  @Column({ unique: true })
  @Index()
  email: string;

  @Column({ length: 400 })
  address: string;

  @Column()
  passwordHash: string;

  @Column({ type: 'enum', enum: UserRole, default: UserRole.NORMAL })
  role: UserRole;

  @OneToMany(() => Rating, rating => rating.user)
  ratings: Rating[];

  async hashPassword(password: string) {
    const salt = await bcrypt.genSalt(10);
    this.passwordHash = await bcrypt.hash(password, salt);
  }

  async validatePassword(password: string): Promise<boolean> {
    return bcrypt.compare(password, this.passwordHash);
  }
}
src/stores/store.entity.ts

TypeScript

import { Entity, PrimaryGeneratedColumn, Column, OneToMany, Index } from 'typeorm';
import { Rating } from '../ratings/rating.entity';

@Entity()
export class Store {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  @Index()
  name: string;

  @Column({ length: 400 })
  @Index()
  address: string;

  @OneToMany(() => Rating, rating => rating.store)
  ratings: Rating[];
}
src/ratings/rating.entity.ts

TypeScript

import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, Unique } from 'typeorm';
import { User } from '../users/user.entity';
import { Store } from '../stores/store.entity';

@Entity()
@Unique(['user', 'store'])
export class Rating {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  rating: number;

  @ManyToOne(() => User, user => user.ratings)
  user: User;

  @ManyToOne(() => Store, store => store.ratings)
  store: Store;
}
3. Backend Modules & Services
We'll use separate modules for auth, users, stores, and ratings to keep the code organized.

src/app.module.ts

TypeScript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { databaseConfig } from './database/database.config';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { StoresModule } from './stores/stores.module';
import { RatingsModule } from './ratings/ratings.module';

@Module({
  imports: [
    TypeOrmModule.forRoot(databaseConfig),
    AuthModule,
    UsersModule,
    StoresModule,
    RatingsModule,
  ],
})
export class AppModule {}
src/main.ts

TypeScript

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.setGlobalPrefix('api');
  app.enableCors();
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
4. Auth Module
This handles user authentication and authorization.

src/auth/auth.module.ts

TypeScript

import { Module } from '@nestjs/common';
import { AuthService } from './auth.service';
import { UsersModule } from '../users/users.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { JwtStrategy } from './jwt.strategy';
import { AuthController } from './auth.controller';
import * as dotenv from 'dotenv';
dotenv.config();

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '1h' },
    }),
  ],
  providers: [AuthService, JwtStrategy],
  controllers: [AuthController],
})
export class AuthModule {}
src/auth/auth.service.ts

TypeScript

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { LoginDto } from './dto/login.dto';
import { User } from '../users/user.entity';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, pass: string): Promise<User | null> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await user.validatePassword(pass))) {
      return user;
    }
    return null;
  }

  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto.email, loginDto.password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }
    const payload = { sub: user.id, username: user.email, role: user.role };
    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
      },
    };
  }
}
src/auth/jwt.strategy.ts

TypeScript

import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from '../users/users.service';
import { User } from '../users/user.entity';
import * as dotenv from 'dotenv';
dotenv.config();

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private usersService: UsersService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: any): Promise<User> {
    const user = await this.usersService.findById(payload.sub);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}
src/auth/auth.controller.ts

TypeScript

import { Controller, Post, Body, UseGuards, Request } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { Public } from './public.decorator';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Public()
  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }
}
5. Users Module
This handles user-related actions like creation, and finding users.

src/users/users.module.ts

TypeScript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
  exports: [UsersService],
})
export class UsersModule {}
src/users/users.service.ts

TypeScript

import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User, UserRole } from './user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private usersRepository: Repository<User>,
  ) {}

  async create(createUserDto: CreateUserDto, role: UserRole = UserRole.NORMAL): Promise<User> {
    const existingUser = await this.usersRepository.findOne({ where: { email: createUserDto.email } });
    if (existingUser) {
      throw new BadRequestException('Email already in use.');
    }
    const user = this.usersRepository.create({ ...createUserDto, role });
    await user.hashPassword(createUserDto.password);
    return this.usersRepository.save(user);
  }

  findAll(query: any): Promise<User[]> {
    const { name, email, address, role, sortBy, sortOrder } = query;
    const findOptions: any = {
      where: {},
      order: { [sortBy || 'name']: sortOrder || 'ASC' },
    };

    if (name) findOptions.where.name = name;
    if (email) findOptions.where.email = email;
    if (address) findOptions.where.address = address;
    if (role) findOptions.where.role = role;

    return this.usersRepository.find(findOptions);
  }

  findById(id: number): Promise<User | undefined> {
    return this.usersRepository.findOne({ where: { id } });
  }

  findByEmail(email: string): Promise<User | undefined> {
    return this.usersRepository.findOne({ where: { email } });
  }

  async updatePassword(id: number, updateDto: UpdateUserDto): Promise<User> {
    const user = await this.findById(id);
    if (!user) {
      throw new BadRequestException('User not found.');
    }
    await user.hashPassword(updateDto.password);
    return this.usersRepository.save(user);
  }
}
6. Stores Module
This handles store-related actions.

src/stores/stores.module.ts

TypeScript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { StoresService } from './stores.service';
import { StoresController } from './stores.controller';
import { Store } from './store.entity';
import { Rating } from '../ratings/rating.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Store, Rating])],
  controllers: [StoresController],
  providers: [StoresService],
  exports: [StoresService],
})
export class StoresModule {}
src/stores/stores.service.ts

TypeScript

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Store } from './store.entity';
import { Repository, SelectQueryBuilder } from 'typeorm';

@Injectable()
export class StoresService {
  constructor(
    @InjectRepository(Store)
    private storesRepository: Repository<Store>,
  ) {}

  async create(createStoreDto: any): Promise<Store> {
    const store = this.storesRepository.create(createStoreDto);
    return this.storesRepository.save(store);
  }

  async findAll(query: any): Promise<Store[]> {
    const { name, address, sortBy, sortOrder } = query;
    const qb: SelectQueryBuilder<Store> = this.storesRepository.createQueryBuilder('store');

    if (name) {
      qb.andWhere('store.name ILIKE :name', { name: `%${name}%` });
    }
    if (address) {
      qb.andWhere('store.address ILIKE :address', { address: `%${address}%` });
    }

    qb.orderBy(`store.${sortBy || 'name'}`, sortOrder || 'ASC');

    return qb.getMany();
  }
}
7. Ratings Module
This handles rating submissions and calculations.

src/ratings/ratings.module.ts

TypeScript

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { RatingsService } from './ratings.service';
import { RatingsController } from './ratings.controller';
import { Rating } from './rating.entity';
import { UsersModule } from '../users/users.module';
import { StoresModule } from '../stores/stores.module';

@Module({
  imports: [TypeOrmModule.forFeature([Rating]), UsersModule, StoresModule],
  controllers: [RatingsController],
  providers: [RatingsService],
})
export class RatingsModule {}
src/ratings/ratings.service.ts

TypeScript

import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Rating } from './rating.entity';
import { Repository } from 'typeorm';

@Injectable()
export class RatingsService {
  constructor(
    @InjectRepository(Rating)
    private ratingsRepository: Repository<Rating>,
  ) {}

  async submitRating(userId: number, storeId: number, ratingValue: number): Promise<Rating> {
    const newRating = this.ratingsRepository.create({
      user: { id: userId },
      store: { id: storeId },
      rating: ratingValue,
    });
    return this.ratingsRepository.save(newRating);
  }

  async updateRating(ratingId: number, ratingValue: number): Promise<Rating> {
    const rating = await this.ratingsRepository.findOne({ where: { id: ratingId } });
    if (!rating) {
      throw new NotFoundException('Rating not found.');
    }
    rating.rating = ratingValue;
    return this.ratingsRepository.save(rating);
  }
}
Frontend (ReactJs) Code
First, initialize your React project.

Bash

npx create-react-app frontend
Then, install the necessary dependencies for the frontend.

Bash

cd frontend
npm install react-router-dom axios
1. Environment Variables (.env.local.example)
Create a .env.local.example file in the frontend directory.

REACT_APP_API_URL=http://localhost:3000/api
2. Core Components & Pages
src/App.js

JavaScript

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './pages/Login';
import Dashboard from './pages/Dashboard';
import Register from './pages/Register';
import PrivateRoute from './components/PrivateRoute';
import { getAuthToken } from './services/authService';

function App() {
  const isAuthenticated = !!getAuthToken();

  return (
    <Router>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/" element={<PrivateRoute />}>
          <Route path="/" element={<Dashboard />} />
        </Route>
        <Route path="*" element={isAuthenticated ? <Navigate to="/" /> : <Navigate to="/login" />} />
      </Routes>
    </Router>
  );
}

export default App;
src/components/PrivateRoute.js

JavaScript

import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { getAuthToken } from '../services/authService';

const PrivateRoute = () => {
  const isAuthenticated = !!getAuthToken();
  return isAuthenticated ? <Outlet /> : <Navigate to="/login" />;
};

export default PrivateRoute;
src/services/authService.js

JavaScript

import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL;

export const login = async (email, password) => {
  const response = await axios.post(`${API_URL}/auth/login`, { email, password });
  localStorage.setItem('user', JSON.stringify(response.data.user));
  localStorage.setItem('token', response.data.access_token);
  return response.data;
};

export const logout = () => {
  localStorage.removeItem('user');
  localStorage.removeItem('token');
};

export const register = async (name, email, address, password) => {
  const response = await axios.post(`${API_URL}/users`, { name, email, address, password, role: 'normal' });
  return response.data;
};

export const getCurrentUser = () => {
  return JSON.parse(localStorage.getItem('user'));
};

export const getAuthToken = () => {
  return localStorage.getItem('token');
};

export const authHeader = () => {
  const token = getAuthToken();
  if (token) {
    return { Authorization: `Bearer ${token}` };
  } else {
    return {};
  }
};
3. Pages
src/pages/Login.js

JavaScript

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { login } from '../services/authService';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      await login(email, password);
      navigate('/');
    } catch (error) {
      alert('Login failed. Please check your credentials.');
    }
  };

  return (
    <div className="login-container">
      <h2>Login</h2>
      <form onSubmit={handleLogin}>
        <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} required />
        <input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} required />
        <button type="submit">Login</button>
      </form>
    </div>
  );
};

export default Login;
src/pages/Register.js

JavaScript

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { register } from '../services/authService';

const Register = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [address, setAddress] = useState('');
  const [password, setPassword] = useState('');
  const navigate = useNavigate();

  const handleRegister = async (e) => {
    e.preventDefault();
    try {
      await register(name, email, address, password);
      alert('Registration successful! Please login.');
      navigate('/login');
    } catch (error) {
      alert('Registration failed. Please try again.');
    }
  };

  return (
    <div className="register-container">
      <h2>Register</h2>
      <form onSubmit={handleRegister}>
        <input type="text" placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} required />
        <input type="email" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} required />
        <input type="text" placeholder="Address" value={address} onChange={(e) => setAddress(e.target.value)} required />
        <input type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} required />
        <button type="submit">Register</button>
      </form>
    </div>
  );
};

export default Register;
4. Dashboard Components
The Dashboard will render different components based on the user's role.

src/pages/Dashboard.js

JavaScript

import React from 'react';
import { getCurrentUser, logout } from '../services/authService';
import { useNavigate } from 'react-router-dom';
import AdminDashboard from '../components/AdminDashboard';
import NormalUserDashboard from '../components/NormalUserDashboard';
import StoreOwnerDashboard from '../components/StoreOwnerDashboard';

const Dashboard = () => {
  const user = getCurrentUser();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const renderDashboard = () => {
    switch (user.role) {
      case 'admin':
        return <AdminDashboard />;
      case 'normal':
        return <NormalUserDashboard />;
      case 'store_owner':
        return <StoreOwnerDashboard />;
      default:
        return <div>Invalid user role.</div>;
    }
  };

  return (
    <div className="dashboard-container">
      <div className="header">
        <h1>Welcome, {user.name}!</h1>
        <button onClick={handleLogout}>Logout</button>
      </div>
      {renderDashboard()}
    </div>
  );
};

export default Dashboard;
src/components/AdminDashboard.js

JavaScript

import React from 'react';
// This component would contain the Admin-specific UI elements:
// - User management (add/view/filter users)
// - Store management (add/view/filter stores)
// - Dashboard stats (total users, stores, ratings)
// It will need to interact with the backend API endpoints for these functionalities.
const AdminDashboard = () => {
  return (
    <div>
      <h3>Admin Dashboard</h3>
      <p>This section is for managing users, stores, and viewing system statistics.</p>
    </div>
  );
};

export default AdminDashboard;
src/components/NormalUserDashboard.js

JavaScript

import React from 'react';
// This component would contain the Normal User-specific UI elements:
// - List of all stores with ratings
// - Search functionality
// - Rating submission/modification forms
const NormalUserDashboard = () => {
  return (
    <div>
      <h3>Normal User Dashboard</h3>
      <p>This section is for viewing and rating stores.</p>
    </div>
  );
};

export default NormalUserDashboard;
src/components/StoreOwnerDashboard.js

JavaScript

import React from 'react';
// This component would contain the Store Owner-specific UI elements:
// - List of users who rated their store
// - Average rating display
const StoreOwnerDashboard = () => {
  return (
    <div>
      <h3>Store Owner Dashboard</h3>
      <p>This section displays your store's ratings and average score.</p>
    </div>
  );
};

export default StoreOwnerDashboard;

